It's important to remember that gcc6809 is mostly just a compiler: converting C code into 6809 assembly language.  However, to form a usable system, you'll need to interface with pre-existing libraries.

GCC6809 itself comes with one default library, called **libgcc**.  It contains routines that are only invoked by the compiler itself.  You do not need to call any of these functions ever.  They are typically used for operations which require a long sequence of instructions and therefore should not be inlined in order to save spaces.  For example, lots of 32-bit math is implemented inside libgcc2.  You simply use "unsigned long" variables as usual and those routines are called automatically.

When you use the gcc frontend as the linker, as opposed to calling ld directly, libgcc is automatically linked in to your program (only the necessary routines will be brought in to the final executable).  gcc itself calls ld and passes it to the -lgcc option to enable this.

The other type of system library is the C library, libc.  Note that libc is intended to be called only from **userspace** programs.  For comparison, note that the Linux kernel does not link against GNU libc, but instead implements its own functions like memcpy, etc.  In its default usage, GCC6809 will also try to link in the C library, and therefore, its default is to assume that you are building a userspace program.  It does this by passing -lc to ld.

Note that you are never forced to use gcc as the linker; you can call ld directly (or even aslink if you don't want to use the GNU-style command-line syntax).  And for writing operating system-like programs, this may even be preferable for more control, but it is not necessary.

Even libc itself is divided into two types of functions: freestanding and hosted.  The freestanding functions are independent of any platform or operating system.  For example, strcpy() basically works the same everywhere; it does not depend on the OS but only on the CPU instruction set.  This is a freestanding function.  On the other hand, something like printf() is very much dependent on your OS.  A UNIX like kernel has a write() system call that it calls to pass the formatted data to the target file.  Other operating systems may do things differently.  If your writing your own kernel, then you may not even allow printf() [Linux they use printk(), which is similar but non-standard and definitely not part of "the C library"](in.md).

If you don't need libc functionality, you can simply ignore it.  GCC6809 by itself can compile your programs just fine.  If you need the freestanding functions, you can either write your own, or grab the 6809 port of newlib, a reasonable but non-optimal implementation of the C library.  This will work regardless of whether you're writing a kernel or running on an arbitrary OS.

Now, if you are writing against a particular OS and want things like printf() to work, you will need to write some additional code.  GCC6809 does not support any standard 6809 operating systems out of the box this way.  newlib has an OS layer that can be ported if you so desire.  It does assume a UNIX-like set of syscalls, so ultimately, you will be writing the guts of read(), write(), open(), etc. from the point of view of a userspace program.  Since every OS is different, and multiple systems might need to be supported on the same build system, you will want to define a new "target type".  Notice that by default gcc6809 installs the compiler as "m6809-unknown-none-gcc".  It is the "unknown" and the "none" that indicate that no particular platform is being targeted.  When newlib is properly ported, you could install the compiler under another name -- which identifies the system support you desire.

Note that the default target type does actually have an implementation for the system calls.  They target an OS-less platform and virtual hardware that is simulated by my simulator, exec09.  The write() system call writes each byte of its input string to a memory-mapped register at a fixed address.  This is meaningless on any real hardware, but the simulator interprets these writes, thus allowing you to do console input/output.  The exit() call which normally terminates a process writes to a special address that tells the simulator to stop.  This was enough to allow the starting/stopping/debugging of problems that was needed to run the GCC testsuite.

To target a real OS, things like write() are more properly implemented as SWI instructions, that would trap into a separate kernel.

You can pass the -nostdlib option to gcc to tell it not to try to link against the C and libgcc libraries.  However, if you do any complex math, you might get compiler errors since libgcc isn't included.